# О строках
Строки полезны для хранения данных, которые могут быть представлены в текстовой форме. Некоторые из наиболее часто используемых операций над строками - это проверка их длины, их построение и объединение с помощью строковых операторов `+` и `+=`, проверка существования или расположения подстрок с помощью метода `indexOf()` или извлечение подстрок с помощью метода `substring()`.

## Instance methods
Методы экземпляра строк.

- `at()` - возвращает символ (ровно одну единицу кода UTF-16) по указанному индексу. Принимает отрицательные целые числа, которые отсчитываются от последнего символа строки,
- `charAt()` - возвращает символ (ровно одну единицу кода UTF-16) по указанному индексу,
- `charCodeAt()` - возвращает число, которое является значением единицы кода UTF-16 по заданному индексу,
- `codePointAt()` - возвращает неотрицательное целое число, которое является значением кодовой точки кодированной точки UTF-16, начиная с указанной позиции,
- `concat()` - объединяет текст двух (или более) строк и возвращает новую строку,
- `endsWith()` - определяет, заканчивается ли строка символами строки searchString,
- `includes()` - определяет, содержит ли вызывающая строка searchString,
- `indexOf()` - возвращает индекс в вызывающем объекте String первого вхождения searchValue или -1, если не найдено,
- `isWellFormed()` - возвращает логическое значение, указывающее, содержит ли эта строка какие-либо одинокие суррогаты,
- `lastIndexOf()` - возвращает индекс в вызывающем объекте String последнего вхождения searchValue или -1, если не найдено,
- `localeCompare()` - возвращает число, указывающее, идет ли ссылочная строка compareString до, после или эквивалентна заданной строке в порядке сортировки,
- `match()` - используется для сопоставления регулярного выражения regexp со строкой,
- `matchAll()` - возвращает итератор всех совпадений регулярного выражения,
- `normalize()` - возвращает форму нормализации Unicode значения вызывающей строки,
- `padEnd()` - заполняет текущую строку с конца заданной строкой и возвращает новую строку длины targetLength,
- `padStart()` - заполняет текущую строку с начала заданной строкой и возвращает новую строку длины targetLength,
- `repeat()` - возвращает строку, состоящую из элементов объекта, повторенных количество раз,
- `replace()` - используется для замены вхождений searchFor с помощью replaceWith. searchFor может быть строкой или регулярным выражением, а replaceWith может быть строкой или функцией,
- `replaceAll()` - используется для замены всех вхождений searchFor с помощью replaceWith. searchFor может быть строкой или регулярным выражением, а replaceWith может быть строкой или функцией,
- `search()` - поиск совпадения между регулярным выражением regexp и вызывающей строкой,
- `slice()` - извлекает часть строки и возвращает новую строку,
- `split()` - возвращает массив строк, заполненных путем разбиения вызывающей строки на вхождения подстроки sep,
- `startsWith()` - определяет, начинается ли вызывающая строка с символов строки searchString,
- `substr()` (Deprecated) - возвращает часть строки, начиная с указанного индекса и далее расширяя заданное количество символов,
- `substring()` - возвращает новую строку, содержащую символы вызывающей строки из (или между) указанного индекса (или индексов),
- `toLocaleLowerCase()` - символы в строке преобразуются в нижний регистр с учетом текущей локали. Для большинства языков это вернет то же самое, что и toLowerCase(),
- `toLocaleUpperCase()` - символы в строке преобразуются в верхний регистр с учетом текущей локали. Для большинства языков это вернет то же самое, что и toUpperCase(),
- `toLowerCase()` - возвращает значение строки вызова, преобразованное в нижний регистр,
- `toString()` - возвращает строку, представляющую указанный объект. Переопределяет метод Object.prototype.toString(),
- `toUpperCase()` - возвращает значение строки вызова, преобразованное в верхний регистр,
- `toWellFormed()` - Возвращает строку, в которой все одиночные суррогаты этой строки заменены символом замены Unicode U+FFFD,
- `trim()` - удаляет пробелы в начале и в конце строки,
- `trimEnd()` - удаляет пробелы с конца строки,
- `trimStart()` - удаляет пробелы с начала строки,
- `valueOf()` - возвращает примитивное значение указанного объекта. Переопределяет метод Object.prototype.valueOf(),
- `String.prototype[@@iterator]()` - возвращает новый объект итератора, который перебирает кодовые точки значения String, возвращая каждую кодовую точку как строковое значение.

## Создание строк
Строки могут быть созданы как примитивы, из строковых литералов или как объекты с помощью конструктора `String()`:

    const string1 = "A string primitive";
    const string2 = 'Also a string primitive';
    const string3 = `Yet another string primitive`;

    const string4 = new String("A String object");

Строковые примитивы и строковые объекты имеют много общего поведения, но имеют другие важные отличия и предостережения. См. раздел "Примитивы String и объекты String" ниже.

Строковые литералы можно указывать с помощью одинарных или двойных кавычек, которые обрабатываются одинаково, или с помощью символа обратной кавычки **`**. Эта последняя форма определяет литерал шаблона: с помощью этой формы вы можете интерполировать выражения. Дополнительные сведения о синтаксисе строковых литералов см. в разделе лексическая грамматика.

## Доступ к символам
Есть два способа получить доступ к отдельному символу в строке. Первый - это метод `charAt()`:

    "cat".charAt(1); // gives value "a"

Другой способ - рассматривать строку как объект, подобный массиву, где отдельные символы соответствуют числовому индексу:

    "cat"[1]; // gives value "a"

При использовании записи в квадратных скобках для доступа к символам попытка удалить или присвоить значение этим свойствам не увенчается успехом. Задействованные свойства не доступны ни для записи, ни для настройки. (См. Object.defineProperty() для получения дополнительной информации.)

## Сравнение строк
Используйте операторы меньше или больше для сравнения строк:

    const b = "b";
    if (a < b) {
      // true
      console.log(`${a} is less than ${b}`);
    } else if (a > b) {
      console.log(`${a} is greater than ${b}`);
    } else {
      console.log(`${a} and ${b} are equal.`);
    }

Обратите внимание, что все операторы сравнения, включая `===` и `==`, сравнивают строки с учетом регистра. Распространенным способом сравнения строк без учета регистра является преобразование обеих строк в один и тот же регистр (верхний или нижний) перед их сравнением.

    function areEqualCaseInsensitive(str1, str2) {
      return str1.toUpperCase() === str2.toUpperCase();
    }

Выбор преобразования с помощью `toUpperCase()` или `toLowerCase()` в основном произвольный, и ни один из них не является полностью надежным при выходе за пределы латинского алфавита. Например, немецкая строчная буква `ß` и `ss` преобразуются в `SS` с помощью `toUpperCase()`, в то время как турецкая буква `ı` будет ложно сообщена как неравная `I` с помощью `toLowerCase()`, если специально не используется `toLocaleLowerCase("tr")`.

    const areEqualInUpperCase = (str1, str2) =>
      str1.toUpperCase() === str2.toUpperCase();
    const areEqualInLowerCase = (str1, str2) =>
      str1.toLowerCase() === str2.toLowerCase();

    areEqualInUpperCase("ß", "ss"); // true; should be false
    areEqualInLowerCase("ı", "I"); // false; should be true

Надежное и учитывающее локаль решение для проверки равенства без учета регистра - использовать API `Intl.Collator` или метод строки `localeCompare()` - они используют один и тот же интерфейс - с параметром `sensitivity`, установленным на `accent` или `base`.

    const areEqual = (str1, str2, locale = "en-US") =>
      str1.localeCompare(str2, locale, { sensitivity: "accent" }) === 0;

    areEqual("ß", "ss", "de"); // false
    areEqual("ı", "I", "tr"); // true

Метод `localeCompare()` позволяет сравнивать строки аналогично методу `strcmp()` - он позволяет сортировать строки с учетом локали.

## Примитивы String и объекты String
Обратите внимание, что JavaScript различает объекты `String` и примитивные строковые значения. То же самое верно для `Boolean` и `Numbers`.

Строковые литералы (обозначаемые двойными или одинарными кавычками) и строки, возвращаемые из вызовов `String` в контексте, не являющемся конструктором (то есть вызываемые без использования ключевого слова `new`), являются примитивными строками. В контекстах, где метод должен быть вызван для примитивной строки или происходит поиск свойства, JavaScript автоматически создаст оболочку строкового примитива и вместо этого вызовет метод или выполнит поиск свойства в объекте-оболочке.

    const strPrim = "foo"; // A literal is a string primitive
    const strPrim2 = String(1); // Coerced into the string primitive "1"
    const strPrim3 = String(true); // Coerced into the string primitive "true"
    const strObj = new String(strPrim); // String with new returns a string wrapper object.

    console.log(typeof strPrim); // "string"
    console.log(typeof strPrim2); // "string"
    console.log(typeof strPrim3); // "string"
    console.log(typeof strObj); // "object"

Предупреждение: вы редко будете использовать `String` в качестве конструктора.

Строковые примитивы и объекты `String` также дают разные результаты при использовании `eval()`. Примитивы, переданные в `eval`, рассматриваются как исходный код; объекты `String` обрабатываются так же, как и все другие объекты, возвращая объект. Например:

    const s1 = "2 + 2"; // creates a string primitive
    const s2 = new String("2 + 2"); // creates a String object
    console.log(eval(s1)); // returns the number 4
    console.log(eval(s2)); // returns the string "2 + 2"

По этим причинам код может сломаться, когда он встречает объекты `String`, вместо которых он ожидает примитивную строку, хотя, как правило, авторам не нужно беспокоиться о различии.

Объект `String` всегда можно преобразовать в его примитивный аналог с помощью метода `valueOf()`.

## String coercion
Многие встроенные операции, которые ожидают строки, сначала приводят свои аргументы к строкам (во многом именно поэтому объекты String ведут себя аналогично строковым примитивам). Операцию можно резюмировать следующим образом:

- Строки возвращаются как есть?
- `undefined` превращается в `"undefined"`,
- `null` превращается в `"null"`,
- `true` превращается в `"true"`,
- `false` превращается в `"false"`,
- Числа преобразуются по тому же алгоритму, что и `toString(10)`,
- BigInts преобразуются по тому же алгоритму, что и `toString(10)`,
- Symbols выдают TypeError.
- Объекты сначала преобразуются в примитив путем вызова его методов `[@@toPrimitive]()` (с подсказкой "string"), toString() и valueOf() в указанном порядке. Полученный примитив затем преобразуется в строку.

Есть несколько способов добиться почти такого же эффекта в JavaScript.

- Литерал шаблона: `${x}` выполняет в точности шаги приведения строки, описанные выше для встроенного выражения,
- Функция String(): String(x) использует тот же алгоритм для преобразования x, за исключением того, что Symbols не выдают TypeError, а возвращают `Symbol(description)`, где description - это описание символа,
- Использование оператора +: `"" + x` приводит свой операнд к примитиву, а не к строке, и для некоторых объектов ведет себя совершенно иначе, чем обычное приведение строки. Смотрите его справочную страницу для более подробной информации.

В зависимости от вашего варианта использования вы можете использовать `${x}` (для имитации встроенного поведения) или String(x) (для обработки значений символов без выдачи ошибки), но вы не должны использовать `"" + x`.

## UTF-16 characters, Unicode code points, and grapheme clusters
Строки представляются в основном как последовательности кодовых единиц UTF-16. В кодировке UTF-16 каждая единица кода имеет длину ровно 16 бит. Это означает, что существует максимум 216 или 65536 возможных символов, которые могут быть представлены как отдельные кодовые единицы UTF-16. Этот набор символов называется базовой многоязычной плоскостью (BMP) и включает в себя наиболее распространенные символы, такие как латинский, греческий, кириллический алфавиты, а также многие восточноазиатские символы. Каждая единица кода может быть записана в виде строки с символом `\u`, за которым следуют ровно четыре шестнадцатеричных цифры.

Однако весь набор символов Unicode намного больше, чем 65536. Дополнительные символы хранятся в UTF-16 в виде суррогатных пар, которые представляют собой пары 16-битных кодовых единиц, представляющих один символ. Во избежание двусмысленности две части пары должны находиться в диапазоне от 0xD800 до 0xDFFF, и эти кодовые единицы не используются для кодирования символов с одной кодовой единицей. (Точнее, старшие суррогаты имеют значения от 0xD800 до 0xDBFF включительно, а младшие суррогаты имеют значения от 0xDC00 до 0xDFFF включительно.) Каждый символ Unicode, состоящий из одной или двух кодовых единиц UTF-16, также называется кодовой точкой Unicode. Каждая кодовая точка Unicode может быть записана в виде строки с \u{xxxxxx}, где xxxxxx представляет 1-6 шестнадцатеричных цифр.

"Одинокий суррогат" - это 16-битная кодовая единица, удовлетворяющая одному из приведенных ниже описаний:
- Он находится в диапазоне от 0xD800 до 0xDBFF включительно (т.е. является старшим суррогатом), но это последняя единица кода в строке или следующая единица кода не является младшим заместителем.
- Он находится в диапазоне от 0xDC00 до 0xDFFF включительно (т.е. является младшим суррогатом), но это первая кодовая единица в строке или предыдущая кодовая единица не является старшей суррогатной.

Одиночные суррогаты не представляют никаких символов Unicode. Хотя большинство встроенных методов JavaScript обрабатывают их правильно, поскольку все они работают на основе кодовых единиц UTF-16, одиночные суррогаты часто не являются допустимыми значениями при взаимодействии с другими системами — например, `encodeURI()` выдаст ошибку `URIError` для одиночных суррогатов, потому что кодировка URI использует кодировку UTF-8, которая не имеет кодировки для одиночных суррогатов. Строки, не содержащие одиночных суррогатов, называются правильно сформированными строками и безопасны для использования с функциями, не работающими с UTF-16 (такими как `encodeURI()` или `TextEncoder`). Вы можете проверить, правильно ли сформирована строка, с помощью метода `isWellFormed()` или очистить одиночные суррогаты с помощью метода `toWellFormed()`.

Помимо символов Unicode, существуют определенные последовательности символов Unicode, которые следует рассматривать как одну визуальную единицу, известную как кластер графем. Наиболее распространенным случаем являются смайлики: многие смайлики, которые имеют ряд вариаций, на самом деле состоят из нескольких смайликов, обычно объединенных символом `<ZWJ> (U+200D)`.

Вы должны быть осторожны, на каком уровне символов вы повторяетесь. Например, `split("")` разделит кодовые единицы UTF-16 и разделит суррогатные пары. Строковые индексы также относятся к индексу каждой единицы кода UTF-16. С другой стороны, `@@iterator()` выполняет итерацию по кодовым точкам Unicode. Итерация по кластерам графем потребует некоторого пользовательского кода.

    "😄".split(""); // ['\ud83d', '\ude04']; splits into two lone surrogates

    // "Backhand Index Pointing Right: Dark Skin Tone"
    [..."👉🏿"]; // ['👉', '🏿']
    // splits into the basic "Backhand Index Pointing Right" emoji and
    // the "Dark skin tone" emoji

    // "Family: Man, Boy"
    [..."👨‍👦"]; // [ '👨', '‍', '👦' ]
    // splits into the "Man" and "Boy" emoji, joined by a ZWJ

    // The United Nations flag
    [..."🇺🇳"]; // [ '🇺', '🇳' ]
    // splits into two "region indicator" letters "U" and "N".
    // All flag emojis are formed by joining two region indicator letters

## Constructor
`String()` - Создает новый объект String. Он выполняет преобразование типов, когда вызывается как функция, а не как конструктор, что обычно более полезно.

## Static methods
- `fromCharCode()` - возвращает строку, созданную с использованием указанной последовательности значений Unicode,
- `fromCodePoint()` - возвращает строку, созданную с использованием указанной последовательности кодовых точек,
- `String.raw()` - возвращает строку, созданную из необработанной строки шаблона.

## Instance properties
Эти свойства определены в `String.prototype` и являются общими для всех экземпляров String.
- `String.prototype.constructor` - функция-конструктор, которая создала экземпляр объекта. Для экземпляров String начальным значением является конструктор String.

Эти свойства являются собственными свойствами каждого экземпляра String.
- `length` - Отражает длину строки. Только для чтения.
