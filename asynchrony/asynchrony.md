# Что такое асинхронность
Асинхронный код не блокирует выполнение кода.  
Асинхронность - одна из мощных возможностей JavaScript.  
Асинхронность - несовпадение процессов во времени.  
Асинхронность не имеет никакого отношения к сетевым запросам AJAX типа XMLHttpRequest() или fetch().

- Асинхронность это когда код выполняется вне основного потока.
- Асинхронность задаётся через колбеки (см. ниже).
- Большая вложенность колбеков усложняет и запутывает код.
- Поэтому придумали промисы `Promise`.

Асинхронность в JavaScript, это:
- таймеры,
- работа с сетью,
- пользовательское взаимодействие.

**Колбэк** *(callback)* - это функция, которая должна быть выполнена после завершения работы другой функции. Её ещё называют функцией обратного вызова.

Асинхронный код это например обращение к серверу и получение данных, поочередная загрузка файлов и т.д. Код который должен выполнится только после того как выполнился предыдущий.

## Разное
При этом, асинхронность не является параллельностью. Асинхронность это когда одному процессу безразличен другой процесс. В JavaScript в один момент времени выполняется одна команда (процесс). При этом не обязательно что эти команды выполняются по порядку, как написаны в коде. В JavaScript одна очередь исполнения команд.

## Примеры асинхронности
Код в setTimeout асинхронный, он не блокирует код до и после него:

    console.log( "До setTimeout" );    // Выполнится первым

    setTimeout( function() {
      console.log( "123" );            // Выполнится третьим
    }, 1000 );

    console.log( "После setTimeout" ); // Выполнится вторым

## Почему setTimeout не блокирует код
Когда интерпретатор доходит до вызова setTimeout(), он начинает заполнять внутри себя определённую `очередь (queue)` (очередь отложенных задач). В этой очереди хранятся объекты, соответствующие функциям, которые должны выполниться в будущем. Каждый такой объект содержит запускаемую функцию, значение задержки срабатывания таймера и время старта этого таймера (имена свойств объектов здесь условные):

    const queue = [
      {
        fn: function() {
          console.log( "123" );
        },
        delay: 1000,
        start: 5476877643565
      }
    ];

В массиве queue может храниться множество объектов запучкающих функции setTimeout, зависит от их количества в самом коде. Интерпретатор, дойдя в коде до setTimeout(), не выполняет записанную в ней функцию, а лишь добавляет в очередь задание на запуск этой функции через определённый промежуток времени.

При этом если основной код будет выполняться 5 секунд, то очередь задач `queue` запуститься через 5 секунд, даже если setTimeout установлен на 1 или 2 секунды.

При запуске функции, заданной в таймере, основным потоком исполнения становится код внутри этой функции. Здесь также могут создаваться свои таймеры, которые будут помещены в ту же очередь отложенных задач и будут обрабатываться вместе с другими таймерами.
