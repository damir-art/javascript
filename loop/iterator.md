# Итератор
Итератор - это фрагмент кода, который перебирает элементы какой-либо коллекции.  
Итераторы - это одна из основных концепций языка JavaScript, на которой базируются его различные механизмы, например, на основе итераторов работает цикл `for ... of` и `spread`-оператор.  
Если говорить более формально, то итератор в JavaScript - это объект, у которого есть метод `next()`.  
Итератор описывает, как нужно перебирать значения.

Например, итератором является цикл `for`, в котором перебираются элементы массива:

    const a = [ 1, 2, 3, 4 ];
    for ( let i = 0; i < a.length; i++ ) {
      console.log(a[i]);
    }

Еще пример итератора. Создадим функцию которая будет генерировать числа в диапазоне от `from` до `to`:

    function range( from, to ) {
      for ( let i = from; i <= to; i++ ) {
        console.log(i);
      }
    }

    range( 5, 11 );

Итератор перебирающий все аргументы функции:

    function sum() {
      var result = 0;
      for ( let i = 0; i < arguments.length; i++ ) {
        // console.log(arguments[i]);
        result += arguments[i];
      }
      return result;
    }

    console.log( sum( 1, 2, 3, 4 ) ); // 10

## next()
Итератор это объект у которого имеется метод `next()`:

    var iterator = {
      next() {

      }
    };

Метод `next()` применяется для каждого элемента перебираемой коллекции и на каждой итерации он должен возвращать объект с двумя свойствами: `value` (значение текущего элемента) и `done` (признак того, что все элементы обработаны).

Чтобы понять, как этот механизм работает, рассмотрим подробно применение итератора в цикле `for ... of` для перебора элементов массива `numbers`:

    const numbers = [ 1, 2, 3, 4 ];
    for ( let element of numbers) {
      ...
    }

В этом случае цикл `for ... of` будет вызывать итератор массива (то есть запускать метод `next()` этого итератора) и проверять значение свойство `done` возвращаемого объекта. Если `done` равен `false`, то метод `next()` вызывается заново, если `done` равно `true`, то перебор массива прекращается.

Для нашего примера на первой итерации метод `next()` вернёт объект `{ value: 1, done: false }`, на второй итерации - объект `{ value: 2, done: false }`, на третьей итерации - объект `{ value: 3, done: false }`, на четвёртой итерации - объект `{ value: 4, done: false }`, а на последней пятой итерации - объект `{ done: true }`.

Данный механизм позволяет циклу `for ... of` перебирать не только массивы, но и любые другие объекты, внутри которых есть итератор, например `arguments`.

## Symbol.iterator
Цикл for ... of узнаёт, есть ли в обрабатываемом объекте итератор, через системный символ `Symbol.iterator`. Если в объекте определён данный символ, то цикл воспринимает его как функцию, возвращающую объект с методом `next()`.

Создадим свой объект с названием `objectWithIterator`, в котором будет определён итератор:

    // Создаём объект
    const objectWithIterator = {};

    // Создаём скрытое свойство через символ
    objectWithIterator[Symbol.iterator] = function () {
      return {
        next() {
          return {
            value: '',
            done: ''
          }
        }
      }
    }

Научим наш объект генерировать число от 0 до 10. Текущее значение числа, которое нужно поместить в свойство value, будем хранить в переменной i. Генерацию чисел нужно прекратить, когда текущее значение значение превысит число 10, поэтому в свойство done мы запишем результат сравнения значения переменной i, увеличенной на единицу, с числом 10.

    // Создаём объект
    const objectWithIterator = {};

    // Создаём скрытое свойство через символ
    objectWithIterator[Symbol.iterator] = function () {
      let i = 0;
      return {
        next() {
          return {
            value: i,
            done: i++ > 10
          }
        }
      }
    }

    // Передаём объект objectWithIterator в цикл for ... of
    for ( const number of objectWithIterator ) {
      console.log( number ); // в консоль выведятся числа от 0 до 10
    }

Доработаем наш пример, сделаем его более универсальным, чтобы можно было генерировать числа в любом заданном диапазоне. Создадим функцию range(), в которую будем передавать начальное и конечное значения для генерации чисел.

Функция range() возвращает объект с итератором, который можно использовать в цикле `for ... of`. Например,сгенерируем с помощью range() последовательность от 3 до 10 и переберём полученные числа в цикле `for ... of`:

    // Функция возвращает объект с итератором
    function range( from, to ) {
      const objectWithIterator = {};

      objectWithIterator[Symbol.iterator] = function () {
        let i = from;
        return {
          next() {
            return {
              value: i,
              done: i++ > to
            }
          }
        }
      }

      return objectWithIterator;
    }

    for ( const number of range( 3, 10 )) {
      console.log(number);
    }

## Итог
Итераторы в JavaScript - это **фрагменты кода**, описывающие, как нужно перебирать тот или иной объект. Создавать итераторы самостоятельно требуется нечасто, однако нужно знать принцип их работы, чтобы понимать механизм работы других конструкций языка JavaScript (например, цикла `for ... of` или spread-оператора).

Когда говорят, что `for ... of` умеет перебирать всё, что можно перебирать, это означает, что этот цикл может перебирать любой объект, у которого есть итератор. Именно итератор указывает, какие элементы и в каком порядке будут попадать в цикл при переборе.

# Старая запись
## Псевдомассивы и итерируемые объекты
Псевдомассивы - это объекты, у которых есть индексы и свойство `length`, к ним можно применять `for ... of` (например строки). 

Итерируемые объекты - это объекты, которые реализуют метод `Symbol.iterator`, for ... of к ним можно применить только через `Symbol.iterator`.

К псевдомассивам и итерируемым объектам нельзя применять методы массивов. Но с помощью `Array.from` их можно превратить в настоящий массив, при условии что ключи в объекте имеют числовые имена, также имеется свойство `length`.

## Разное
- итерируемые объекты которые можно использовать в цикле `for ... of` называются итерируемыми,
- итерируются те объекты которые имеют встроенный `Symbol.iterator`, если его нет то его можно добавить,
- псевдомассив не является итерируемым объектом.

## Symbol.iterator
`for ... of` не может перебрать объект `Object`, чтобы сделать его итерируемым, нужно добавить в него `Symbol.iterator`:

    const obj = {
      from: 1,
      to: 5
    }

    for (let val of obj) {
      console.log(val)    // ошибка
    }
