# Замыкание
Переменная - это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.

Работа с переменными - это на самом деле работа со свойствами этого объекта.

Замыкание - это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JavaScript, все функции изначально являются замыканиями.

В JavaScript можно разнообразно работаь с функциями:
- динамически создавать
- копировать в переменные
- передавать как аргументы другой функции
- и мн.др

Функция может получить доступ к переменным из внешнего окружения:

    let name = 'Джон'

    function getName (a) {
        console.log(a)
    }

    name = 'Питер'
    getName(name) // Питер

Возврат функции:

    function getName () {
        let name = 'Джон'

        return function () {
            console.log(name)
        }
    }

    let name = 'Питер'
    let fooName = getName()
    fooName() // Джон

## LexicalEnvironment
У каждой функции, блока кода, скрипта есть связанный с ними скрытый объект - `LexicalEnvironment`.

Объект лексического окружения `LexicalEnvironment`, состоит из двух частей:
- `Environment Record` - объект (хранилище переменных), в котором как свойства хранятся все локальные переменные и другая информация, например такая как `this`
- Ссылка на внешнее лексическое окружение, коду снаружи от текущих фигурных скобок
- При каждом новом вызове, создаётся новое лексическое окружение
- лексическое окружение существует для любых блоков `{ }` кода
- у циклов, лексическое окружение создаётся при каждой итерации
- чтобы изолировать имена переменных от других файлов со скриптами, можно их в файле заключать в `{ }`

## Function Declaration (обычная функция)
Переменные объявленные с помощью `let` инициализируются в лексическом окружении когда до них доходит интерператор. Функции инициализируются во время создания лексического окружения. Поэтому Function Declaration, можно вызывать до того как она определена.

Функция тоже является свойством `Environment Record`.

## Вложенная функция
У `counter` и `counter2` свое собственное лексическое окружение и переменная `count`.

    function makeCounter() {
    let count = 0;

    return function() {
        return count++; // есть доступ к внешней переменной "count"
    };
    }

    let counter = makeCounter();
    let counter2 = makeCounter();

    console.log( counter() ) // 0
    console.log( counter() ) // 1
    console.log( counter() ) // 2

    console.log( counter2() ) // 0
    console.log( counter2() ) // 1
    console.log( counter2() ) // 2

## IIFE
IIFE использовали до того как в JavaScript появилось лексическое окружение.
IIFE - функция запускаемая сразу после объявления.

    (function() {
        let str = 'Hello'
        console.log(str) // Hello
    })()

## Сборка мусора
После того как функция выполняется, лексическое окружение вместе с переменными удаляются.
Если используется вложенная функция, то она ссылается лексическое окружение родителя, тогда они не удаляются.

    function f() {
        let value = Math.random()
        return function() { console.log(value) }
    }

    let a = f() // лексическое окружение существует, пока существует `a`
    a()
    a()
    a()

    let a = null // удаляем `a` и лексическое окружение

## Разное
- `{}` блоки кода имеют лексическое окружение
- при оптимизации движок V8 удаляет объявленные переменные если они не используются в коде, например внутри функции объявлена переменная и если она не используется внутри функции то через дебаггер её не видно, переменная удалена оптимизатором движка.
- `let` и `const` ведут себя одинаково по отношению к лексическому окружению, `var` использовать не нужно

# Замыкание (старая запись)
Замыкание - это сделать переменную приватной.
Замыкание - это использовать значение из внешней области видимости.
Замыкание - это когда функция находится внутри другой функции. Используется для создания локальных переменных, чьи значения можно сохранить и передать другим функциям (создать счетчик).

Замыкание в JavaScript - это явление, когда вызывается функция, определенная внутри другой (родительской) функции, после того как родительская функция уже завершила свою работу.

Замыкание - это возможность языка создавать локальный `scope` *(область видимости)* данных, и затем с ним работать. При замыкании у каждой сушности *(например counterA и counterB)* свои собственные переменные.

Для изучения замыканий, создадим функцию, которая будет возвращать функцию или объект. Локальные переменные функции замыкаются в функциях и методах находящихся в `return`.

Теперь мы можем создавать сходные сущности у которых своя область видимости и переменные.

## Создали счетчик

    let count = 0;
    function closure () {
        count = count + 1
        return count
    }

    let x = closure()
    let y = closure()
    let z = closure()

    console.log(x, y, z) // 1, 2, 3

## Создали счетчик через анонимную функцию
К переменной `count` имеет доступ только анонимная функция.

    function closure () {
        let count = 0; // аналог приватного свойства
        return function () {
            count = count + 1
            return count
        }
    }

    let x = closure()
    let y = closure()
    let z = closure()

    console.log(x(), x(), x()) // 1, 2, 3
    console.log(x(), y(), z()) // 4, 1, 1

У каждой переменной своё значение `count`.

## Замыкание. Возвращаем функцию

    var createCounter = function(counterName) {
        var counter = 0

        return function() {
            console.log(counterName, ++counter)
        }
    }

    // функция одна и та же, область видимости у функции разная,
    // с собственными переменными counter - это и есть замыкание
    var counterA = createCounter('Counter A')
    var counterB = createCounter('Counter B')

    counterA() // 1
    counterA() // 2
    counterB() // 1
    counterA() // 3

    // набираем в консоли или console.log(counterA), console.log(counterB)
    // в пременных counterA, counterB хранится объявление функции createCounter()
    counterA
    counterB

## Замыкание. Возвращаем объект

    var createCounter = function() {
        var counter = 0

        return {
            increment: function() {
                counter++
            },
            decrement: function() {
                counter--
            },
            getCounter: function() {
                return counter
            }
        }
    }

    // Переменные являются объектами
    var counterA = createCounter('Counter A')
    var counterB = createCounter('Counter B')

    // counter = 3
    counterA.increment()
    counterA.increment()
    counterA.increment()

    // counter = -2
    counterB.decrement()
    counterB.decrement()

    console.log(counterA.getCounter()) // 3
    console.log(counterB.getCounter()) // -2
